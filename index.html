"use strict";

/**
 * taitruyen-stable.js (Interactive + CLI) - SUPPORT DECIMAL CHAP (chap_102.5.html => chap_0102.5)
 * ------------------------------------------------------------
 * ‚úÖ ƒê·ªçc th∆∞ m·ª•c ch·ª©a chap_XXXX(.Y).html / chap_XXXX(.Y).txt (h·ªó tr·ª£ .html/.htm)
 * ‚úÖ Normalize chap: chap_122.5.html / chap_0122.5.html => chap_0122.5
 * ‚úÖ B√≥c ·∫£nh t·ª´ HTML (selector + fallback regex)
 * ‚úÖ H·ªó tr·ª£ src t∆∞∆°ng ƒë·ªëi nh∆∞ /image.php?url=... b·∫±ng --base (ho·∫∑c nh·∫≠p khi ch·∫°y)
 * ‚úÖ Unwrap url=... ƒë·ªÉ l·∫•y ·∫£nh g·ªëc (v√† v·∫´n fallback t·∫£i qua proxy n·∫øu ·∫£nh g·ªëc b·ªã ch·∫∑n)
 * ‚úÖ Check Content-Type ƒë·ªÉ tr√°nh l∆∞u HTML/403 th√†nh ·∫£nh
 * ‚úÖ Resume: file t·ªìn t·∫°i th√¨ b·ªè qua; ghi .part r·ªìi rename ƒë·ªÉ tr√°nh file d·ªü
 * ‚úÖ N·∫øu chapDir ƒë√£ c√≥ ·∫£nh -> v·∫´n ƒë·ªçc chap ƒë·ªÉ ki·ªÉm tra thi·∫øu ·∫£nh n√†o v√† ch·ªâ t·∫£i ·∫£nh c√≤n thi·∫øu
 * ‚úÖ Keep-Alive agents + proxy-first
 * ‚úÖ Auto load cookies from auth.json (Playwright storageState) n·∫øu c√≥ -> gi·∫£m 403
 * ‚úÖ Headful/Headless (Interactive + CLI)
 * ‚úÖ Press "r" anytime -> ABORT chap ƒëang t·∫£i + X√ìA folder chap ƒëang d·ªü + restart t·ª´ chap ƒë·∫ßu
 * ‚úÖ Ghi failed_images.txt + failed_chaps.txt + debug html n·∫øu chap kh√¥ng b√≥c ƒë∆∞·ª£c ·∫£nh
 *
 * C√†i:
 *   npm i axios cheerio p-limit
 *   npm i playwright   (ch·ªâ c·∫ßn n·∫øu d√πng headful ƒë·ªÉ login/l∆∞u auth.json)
 *
 * Ch·∫°y (t∆∞∆°ng t√°c):
 *   node taitruyen-stable.js
 *
 * Ch·∫°y (CLI):
 *   node taitruyen-stable.js "D:\chap_html" --base="https://www.bluelakeaccelerator.com" --out="output" --concurrency=3 --headful
 *   node taitruyen-stable.js "D:\chap_html" --base="https://www.bluelakeaccelerator.com" --headless
 */

const fs = require("fs");
const path = require("path");
const axios = require("axios");
const http = require("http");
const https = require("https");
const cheerio = require("cheerio");
const readline = require("readline");

/* ================== FIX p-limit (ESM/CJS) ================== */
let pLimit;
try {
  const mod = require("p-limit");
  pLimit = mod && typeof mod === "object" && mod.default ? mod.default : mod;
  if (typeof pLimit !== "function") {
    throw new Error("p-limit loaded but not a function (ESM/CJS mismatch).");
  }
} catch (e) {
  console.error("‚ùå Kh√¥ng load ƒë∆∞·ª£c 'p-limit'.");
  console.error("   H√£y ch·∫°y: npm i p-limit");
  console.error("   L·ªói chi ti·∫øt:", e?.message || e);
  process.exit(1);
}

/* ================== INTERACTIVE PROMPT ================== */
function ask(question) {
  const rl = readline.createInterface({ input: process.stdin, output: process.stdout });
  return new Promise((resolve) => {
    rl.question(question, (answer) => {
      rl.close();
      resolve(String(answer || "").trim());
    });
  });
}

function waitEnter(msg) {
  const rl = readline.createInterface({ input: process.stdin, output: process.stdout });
  return new Promise((resolve) => {
    rl.question(msg, () => {
      rl.close();
      resolve();
    });
  });
}

/* ================== ARG PARSE ================== */
function parseArgs(argv) {
  const out = { _: [] };
  for (const a of argv.slice(2)) {
    if (a.startsWith("--")) {
      const [k, v] = a.split("=");
      out[k.replace(/^--/, "")] = v ?? true;
    } else {
      out._.push(a);
    }
  }
  return out;
}

const args = parseArgs(process.argv);

// Cho ph√©p v·ª´a CLI v·ª´a interactive
let HTML_ROOT = args._[0] || null;
let OUTPUT_ROOT = args.out ? String(args.out) : null;
let BASE_URL = args.base ? String(args.base) : null;
let CONCURRENCY = args.concurrency ? parseInt(String(args.concurrency), 10) : null;

// options ph·ª•
const ONLY_UNWRAP = args.only_unwrap === "1" || args.only_unwrap === true; // n·∫øu mu·ªën ch·ªâ t·∫£i ·∫£nh g·ªëc sau unwrap
const TIMEOUT = 30000;
const RETRY_IMG = 3;
const DELAY_CHAP_MIN = 1200;
const DELAY_CHAP_MAX = 2500;

// ‚úÖ HEADFUL/HEADLESS (CLI + interactive)
let HEADFUL = args.headful === true || String(args.headful || "").toLowerCase() === "true";
let HEADLESS = args.headless === true || String(args.headless || "").toLowerCase() === "true";
// N·∫øu user kh√¥ng truy·ªÅn g√¨: s·∫Ω h·ªèi interactive. (m·∫∑c ƒë·ªãnh headless)
let ASK_BROWSER_MODE = !(HEADFUL || HEADLESS);

/* ================== KEEP-ALIVE AGENTS ================== */
const httpAgent = new http.Agent({ keepAlive: true, maxSockets: 50 });
const httpsAgent = new https.Agent({ keepAlive: true, maxSockets: 50 });

/* ================== CONFIG ================== */
const IMAGE_SELECTORS = [
  "div.list-image-detail img",
  "div.reading-detail img",
  "div.reading-content img",
  "article img",
  "img",
];

function buildHeaders(baseUrl) {
  const h = {
    "User-Agent":
      "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 Chrome/120 Safari/537.36",
    Accept: "image/avif,image/webp,image/*,*/*;q=0.8",
    "Accept-Language": "vi-VN,vi;q=0.9,en;q=0.8",
    Connection: "keep-alive",
  };
  if (baseUrl) {
    h.Referer = baseUrl;
    try {
      h.Origin = new URL(baseUrl).origin;
    } catch {}
  }
  return h;
}

/* ================== UTILS ================== */
const sleep = (ms) => new Promise((r) => setTimeout(r, ms));
const randDelay = (a, b) => Math.floor(Math.random() * (b - a + 1)) + a;

function ensureDir(p) {
  if (!fs.existsSync(p)) fs.mkdirSync(p, { recursive: true });
}

function safeName(name) {
  return String(name || "").replace(/[\\/:*?"<>|]/g, "").trim() || "UnknownSeries";
}

function dedupe(arr) {
  const seen = new Set();
  const out = [];
  for (const x of arr) {
    if (!x) continue;
    if (!seen.has(x)) {
      seen.add(x);
      out.push(x);
    }
  }
  return out;
}

/* ================== CHAP FILE NAME (supports decimals + .htm) ================== */
// Accept:
//  chap_122.html / chap_0122.html
//  chap_122.5.html / chap_0122.5.html
//  chap_122,5.html (n·∫øu c√≥)
//  .html / .htm / .txt
function isChapFile(name) {
  const n = String(name || "").trim();
  return /^chap_\d+(?:[.,]\d+)?\.(html?|txt)$/i.test(n);
}

function parseChapKey(name) {
  const n = String(name || "").trim();
  const m = n.match(/^chap_(\d+)(?:[.,](\d+))?\.(html?|txt)$/i);
  if (!m) return null;

  const intStr = m[1];
  const fracStr = m[2] || null;

  const intNum = parseInt(intStr, 10);
  const fracFloat = fracStr ? parseFloat("0." + fracStr) : 0;

  return {
    int: Number.isFinite(intNum) ? intNum : 0,
    frac: fracFloat, // for sorting
    fracStr,
    hasFrac: !!fracStr,
  };
}

// Normalize:
// chap_122.html      -> "0122"
// chap_0122.html     -> "0122"
// chap_122.5.html    -> "0122.5"
// chap_0122.5.html   -> "0122.5"
function chapNumber(name) {
  const key = parseChapKey(name);
  if (!key) return null;

  const intPart = String(key.int).padStart(4, "0");
  return key.hasFrac ? `${intPart}.${key.fracStr}` : intPart;
}

function normalizeMaybeRelativeUrl(u, baseUrl) {
  if (!u) return null;
  u = String(u).trim();
  if (!u) return null;

  if (/^(javascript:|data:)/i.test(u)) return null;

  if (u.startsWith("//")) return "https:" + u;
  if (/^https?:\/\//i.test(u)) return u;

  if (baseUrl) {
    try {
      return new URL(u, baseUrl).toString();
    } catch {
      return u;
    }
  }
  return u;
}

function unwrapProxyImageUrl(u) {
  try {
    const urlObj = new URL(u);
    const real = urlObj.searchParams.get("url");
    if (real && /^https?:\/\//i.test(real)) return real;
  } catch {}
  return null;
}

function extFromUrl(u) {
  try {
    const urlObj = new URL(u);
    const pathname = urlObj.pathname.toLowerCase();
    const m = pathname.match(/\.(jpg|jpeg|png|webp|gif|bmp|avif)$/i);
    if (m) return m[1] === "jpeg" ? "jpg" : m[1];
  } catch {}
  return null;
}

function extFromContentType(ct) {
  if (!ct) return null;
  ct = String(ct).toLowerCase();
  if (ct.includes("image/jpeg")) return "jpg";
  if (ct.includes("image/png")) return "png";
  if (ct.includes("image/webp")) return "webp";
  if (ct.includes("image/gif")) return "gif";
  if (ct.includes("image/bmp")) return "bmp";
  if (ct.includes("image/avif")) return "avif";
  return null;
}

/* ================== EXISTING IMAGES INDEXES (0001.*) ================== */
function getExistingImageIndexes(chapDir) {
  const set = new Set();
  if (!fs.existsSync(chapDir)) return set;
  try {
    const files = fs.readdirSync(chapDir);
    const re = /^(\d{4})\.(jpg|jpeg|png|webp|gif|bmp|avif)$/i;
    for (const f of files) {
      const m = String(f).match(re);
      if (!m) continue;
      const full = path.join(chapDir, f);
      let st;
      try {
        st = fs.statSync(full);
      } catch {
        continue;
      }
      if (!st.isFile() || st.size <= 0) continue;
      set.add(parseInt(m[1], 10)); // 1..n
    }
  } catch {}
  return set;
}

/* ================== PARSE IMAGES ================== */
function extractImagesByDom(html, baseUrl) {
  const $ = cheerio.load(html);
  const baseHref = $("base").attr("href");
  const effectiveBase = baseHref ? baseHref : baseUrl;

  const urls = [];
  for (const sel of IMAGE_SELECTORS) {
    $(sel).each((_, img) => {
      const raw =
        $(img).attr("data-src") ||
        $(img).attr("data-original") ||
        $(img).attr("data-lazy") ||
        $(img).attr("data-url") ||
        $(img).attr("src");

      const u = normalizeMaybeRelativeUrl(raw, effectiveBase);
      if (u) urls.push(u);
    });
    if (urls.length) break;
  }
  return dedupe(urls);
}

function extractImagesByRegex(html) {
  const urls = [];
  const re = /(https?:\/\/[^"' \n\r\t]+?\.(jpg|jpeg|png|webp|gif|bmp|avif))(\?[^"' \n\r\t]*)?/gi;
  let m;
  while ((m = re.exec(html)) !== null) urls.push(m[0]);
  return dedupe(urls);
}

/* ================== SERIES NAME ================== */
function getSeriesNameFromAnyUrl(url, baseUrl) {
  try {
    const u = new URL(url);
    const parts = u.pathname.split("/").filter(Boolean);
    if (parts.length) return safeName(decodeURIComponent(parts[0]));
    return safeName(u.hostname);
  } catch {
    if (baseUrl) {
      try {
        return safeName(new URL(baseUrl).hostname);
      } catch {}
    }
    return "UnknownSeries";
  }
}

/* ================== LOAD COOKIES FROM auth.json ================== */
function loadStorageStateCookies(authPath) {
  try {
    if (!authPath || !fs.existsSync(authPath)) return [];
    const raw = fs.readFileSync(authPath, "utf8");
    const json = JSON.parse(raw);
    const cookies = Array.isArray(json?.cookies) ? json.cookies : [];
    return cookies;
  } catch {
    return [];
  }
}

function domainMatch(host, cookieDomain) {
  if (!host || !cookieDomain) return false;
  const h = host.toLowerCase();
  let d = String(cookieDomain).toLowerCase();
  if (d.startsWith(".")) d = d.slice(1);
  return h === d || h.endsWith("." + d);
}

function pathMatch(reqPath, cookiePath) {
  const p = reqPath || "/";
  const c = cookiePath || "/";
  if (p === c) return true;
  if (!p.startsWith("/")) return false;
  if (!c.endsWith("/")) return p.startsWith(c);
  return p.startsWith(c);
}

function buildCookieHeaderForUrl(urlStr, cookies) {
  if (!cookies || !cookies.length) return "";
  try {
    const u = new URL(urlStr);
    const host = u.hostname;
    const reqPath = u.pathname || "/";
    const now = Date.now() / 1000;
    const isHttps = u.protocol === "https:";

    const pairs = [];
    for (const ck of cookies) {
      if (!ck || !ck.name) continue;
      if (ck.expires && ck.expires > 0 && ck.expires < now) continue;
      if (ck.secure && !isHttps) continue;
      if (!domainMatch(host, ck.domain || host)) continue;
      if (!pathMatch(reqPath, ck.path || "/")) continue;
      pairs.push(`${ck.name}=${ck.value || ""}`);
    }
    return pairs.join("; ");
  } catch {
    return "";
  }
}

/* ================== HEADFUL LOGIN & SAVE auth.json ================== */
async function maybeLoginAndSaveAuth({ enabled, baseUrl }) {
  if (!enabled) return;

  let chromium;
  try {
    ({ chromium } = require("playwright"));
  } catch (e) {
    console.log("‚ùå B·∫°n ch·ªçn HEADFUL nh∆∞ng ch∆∞a c√†i Playwright.");
    console.log("   H√£y ch·∫°y: npm i playwright");
    process.exit(1);
  }

  const authPath = path.join(process.cwd(), "auth.json");

  console.log("\nüß≠ HEADFUL MODE: M·ªü tr√¨nh duy·ªát ƒë·ªÉ b·∫°n login th·ªß c√¥ng (n·∫øu c·∫ßn).");
  console.log("   - Login/Captcha xong ‚Üí quay l·∫°i terminal v√† nh·∫•n Enter ƒë·ªÉ l∆∞u auth.json");
  console.log("   - N·∫øu b·∫°n kh√¥ng c·∫ßn login, c·ª© ƒë√≥ng tab / kh√¥ng l√†m g√¨ c≈©ng ƒë∆∞·ª£c.\n");

  const target = baseUrl || "https://www.google.com";
  const browser = await chromium.launch({ headless: false });
  const context = await browser.newContext();
  const page = await context.newPage();

  await page.goto(target, { waitUntil: "load" }).catch(() => {});
  await waitEnter("üëâ Login xong (ho·∫∑c b·ªè qua) ‚Üí nh·∫•n Enter ƒë·ªÉ L∆ØU auth.json v√† ti·∫øp t·ª•c... ");

  try {
    await context.storageState({ path: authPath });
    console.log(`‚úÖ ƒê√£ l∆∞u auth.json t·∫°i: ${authPath}`);
  } catch (e) {
    console.log("‚ö†Ô∏è Kh√¥ng l∆∞u ƒë∆∞·ª£c auth.json:", e?.message || e);
  }

  await browser.close().catch(() => {});
}

/* ================== ABORT HELPERS ================== */
function throwIfAborted(signal) {
  if (signal?.aborted) throw new Error("ABORTED");
}

/* ================== HTTP DOWNLOAD (Abortable) ================== */
async function axiosGetBuffer(url, headers, signal) {
  return axios.get(url, {
    responseType: "arraybuffer",
    timeout: TIMEOUT,
    headers,
    validateStatus: (s) => s >= 200 && s < 300,
    maxRedirects: 5,
    httpAgent,
    httpsAgent,
    signal,
  });
}

async function downloadWithRetry(url, headers, signal) {
  let lastErr = null;
  for (let i = 1; i <= RETRY_IMG; i++) {
    throwIfAborted(signal);
    try {
      return await axiosGetBuffer(url, headers, signal);
    } catch (e) {
      if (
        signal?.aborted ||
        e?.code === "ERR_CANCELED" ||
        String(e?.message || "").toLowerCase().includes("canceled")
      ) {
        throw new Error("ABORTED");
      }
      lastErr = e;
      await sleep(900 + i * 600);
    }
  }
  throw lastErr || new Error("download failed");
}

function isImageContentType(ct) {
  return String(ct || "").toLowerCase().startsWith("image/");
}

function looksLikeImage(buf, ct) {
  const b = buf;
  if (!b || b.length < 12) return false;
  const c = String(ct || "").toLowerCase();
  if (c.includes("jpeg")) return b[0] === 0xff && b[1] === 0xd8;
  if (c.includes("png")) return b[0] === 0x89 && b[1] === 0x50 && b[2] === 0x4e;
  if (c.includes("gif")) return b[0] === 0x47 && b[1] === 0x49 && b[2] === 0x46;
  if (c.includes("webp")) return b[0] === 0x52 && b[1] === 0x49 && b[2] === 0x46 && b[8] === 0x57;
  return true;
}

async function trySaveFromUrl({ index, url, chapDir, headers, signal }) {
  throwIfAborted(signal);

  const extGuess = extFromUrl(url);
  const res = await downloadWithRetry(url, headers, signal);

  throwIfAborted(signal);

  const ct = res.headers?.["content-type"] || "";
  if (!isImageContentType(ct)) {
    return { ok: false, reason: `Non-image content-type: ${ct || "unknown"}` };
  }

  const buf = Buffer.from(res.data || []);
  if (!buf.length) return { ok: false, reason: "Empty response body" };
  if (!looksLikeImage(buf, ct)) return { ok: false, reason: "Corrupted/non-image body" };

  const ext = extFromContentType(ct) || extGuess || "jpg";
  const filename = String(index).padStart(4, "0") + "." + ext;
  const savePath = path.join(chapDir, filename);

  // folder chap c√≥ th·ªÉ b·ªã x√≥a khi restart
  if (!fs.existsSync(chapDir)) throw new Error("ABORTED");

  if (fs.existsSync(savePath) && fs.statSync(savePath).size > 0) {
    return { ok: true, skipped: true, filename };
  }

  // write .part then rename
  const tmp = savePath + ".part";
  fs.writeFileSync(tmp, buf);
  fs.renameSync(tmp, savePath);

  return { ok: true, filename };
}

/**
 * Strategy:
 * - ONLY_UNWRAP: ch·ªâ t·∫£i ·∫£nh g·ªëc (unwrap)
 * - Default: proxy-first -> fail th√¨ unwrap fallback
 * - m·ªói request t·ª± g·∫Øn Cookie (n·∫øu c√≥ auth.json) theo domain
 */
async function saveImageStable({ index, rawUrl, chapDir, headers, baseUrl, cookies, signal }) {
  const absUrl = normalizeMaybeRelativeUrl(rawUrl, baseUrl);
  if (!absUrl) return { ok: false, reason: "Empty/invalid URL" };

  let unwrapped = null;
  try {
    unwrapped = unwrapProxyImageUrl(absUrl);
  } catch {
    unwrapped = null;
  }

  const attachCookie = (urlStr) => {
    const cookieStr = buildCookieHeaderForUrl(urlStr, cookies);
    if (!cookieStr) return headers;
    return { ...headers, Cookie: cookieStr };
  };

  if (ONLY_UNWRAP) {
    if (!unwrapped) return { ok: false, reason: "No unwrap URL" };
    try {
      return await trySaveFromUrl({
        index,
        url: unwrapped,
        chapDir,
        headers: attachCookie(unwrapped),
        signal,
      });
    } catch (e) {
      return { ok: false, reason: e?.message || "unwrap download error" };
    }
  }

  // 1) proxy-first
  try {
    const r1 = await trySaveFromUrl({
      index,
      url: absUrl,
      chapDir,
      headers: attachCookie(absUrl),
      signal,
    });
    if (r1.ok) return r1;
  } catch (e) {
    if (e?.message === "ABORTED") return { ok: false, reason: "ABORTED" };
  }

  // 2) unwrap fallback
  if (unwrapped) {
    try {
      return await trySaveFromUrl({
        index,
        url: unwrapped,
        chapDir,
        headers: attachCookie(unwrapped),
        signal,
      });
    } catch (e) {
      return { ok: false, reason: e?.message || "unwrap download error" };
    }
  }

  return { ok: false, reason: "download error" };
}

/* ================== CHAP READ ================== */
function readChapContent(fullPath) {
  const raw = fs.readFileSync(fullPath, "utf8");
  const ext = path.extname(fullPath).toLowerCase();
  if (ext === ".txt") {
    const lines = raw.split(/\r?\n/).map((s) => s.trim()).filter(Boolean);
    const urls = [];
    for (const line of lines) {
      const m = line.match(/https?:\/\/\S+/i);
      if (m) urls.push(m[0]);
    }
    return { kind: "txt", raw, urls: dedupe(urls) };
  }
  return { kind: "html", raw, urls: null };
}

/* ================== PRESS "r" TO RESTART ================== */
let RESTART_REQUESTED = false;
let CURRENT_RUN_ID = 0;

let CURRENT_CHAP_DIR = null;
let CURRENT_CHAP_ABORT = null;

let _restartResolver = null;
function makeRestartPromise() {
  return new Promise((resolve) => (_restartResolver = resolve));
}
let restartPromise = makeRestartPromise();

function deleteDirSafe(dirPath) {
  if (!dirPath) return;
  try {
    if (fs.existsSync(dirPath)) {
      fs.rmSync(dirPath, { recursive: true, force: true });
      console.log(`üóëÔ∏è  ƒê√£ x√≥a folder chap ƒëang d·ªü: ${dirPath}`);
    }
  } catch (e) {
    console.log(`‚ö†Ô∏è Kh√¥ng x√≥a ƒë∆∞·ª£c folder chap (${dirPath}): ${e?.message || e}`);
  }
}

function requestRestartNow() {
  if (RESTART_REQUESTED) return;
  RESTART_REQUESTED = true;

  console.log("\nüîÅ RESTART (r): abort chap hi·ªán t·∫°i + x√≥a folder chap + quay v·ªÅ chap ƒë·∫ßu...");

  try {
    CURRENT_CHAP_ABORT?.abort();
  } catch {}

  deleteDirSafe(CURRENT_CHAP_DIR);

  try {
    _restartResolver?.();
  } catch {}
}

function installRestartHotkey() {
  if (!process.stdin.isTTY) {
    console.log("‚ö†Ô∏è Kh√¥ng th·ªÉ b·∫Øt ph√≠m 'r' v√¨ stdin kh√¥ng ph·∫£i TTY (ch·∫°y trong m√¥i tr∆∞·ªùng kh√¥ng t∆∞∆°ng t√°c).");
    return;
  }

  process.stdin.setEncoding("utf8");
  process.stdin.setRawMode(true);
  process.stdin.resume();

  console.log("üí° Hotkey: nh·∫•n 'r' b·∫•t k·ª≥ l√∫c n√†o ƒë·ªÉ restart (abort + x√≥a chap ƒëang d·ªü). Nh·∫•n 'q' ƒë·ªÉ tho√°t.");

  process.stdin.on("data", (key) => {
    const k = String(key);
    if (k === "\u0003") process.exit(0);

    if (k.toLowerCase() === "q") {
      console.log("\nüëã Tho√°t theo y√™u c·∫ßu (q).");
      process.exit(0);
    }

    if (k.toLowerCase() === "r") {
      requestRestartNow();
    }
  });
}

function ensureNoRawModeOnExit() {
  const cleanup = () => {
    try {
      if (process.stdin.isTTY) process.stdin.setRawMode(false);
    } catch {}
  };
  process.on("exit", cleanup);
  process.on("SIGINT", () => process.exit(0));
  process.on("SIGTERM", () => process.exit(0));
}

async function sleepInterruptible(ms) {
  const step = 120;
  let left = ms;
  while (left > 0) {
    if (RESTART_REQUESTED) return;
    const s = Math.min(step, left);
    await sleep(s);
    left -= s;
  }
}

/* ================== MAIN ================== */
async function main() {
  installRestartHotkey();
  ensureNoRawModeOnExit();

  if (!HTML_ROOT) {
    HTML_ROOT = await ask("üìÅ Nh·∫≠p th∆∞ m·ª•c ch·ª©a chap (vd: D:\\chap_html): ");
  }
  if (!HTML_ROOT || !fs.existsSync(HTML_ROOT)) {
    console.log("‚ùå Th∆∞ m·ª•c kh√¥ng t·ªìn t·∫°i:", HTML_ROOT);
    process.exit(1);
  }

  if (!BASE_URL) {
    BASE_URL = await ask("üåê Nh·∫≠p base URL (vd: https://www.bluelakeaccelerator.com) [Enter n·∫øu kh√¥ng c·∫ßn]: ");
    if (!BASE_URL) BASE_URL = null;
  }

  if (ASK_BROWSER_MODE) {
    const m = await ask("üß™ Ch·ªçn ch·∫ø ƒë·ªô tr√¨nh duy·ªát? (1=Headless, 2=Headful m·ªü tr√¨nh duy·ªát login) [Enter=1]: ");
    if (String(m || "").trim() === "2") {
      HEADFUL = true;
      HEADLESS = false;
    } else {
      HEADLESS = true;
      HEADFUL = false;
    }
  } else {
    if (HEADFUL) HEADLESS = false;
    if (!HEADFUL && !HEADLESS) HEADLESS = true;
  }

  if (HEADFUL) {
    const yn = await ask("üç™ B·∫°n mu·ªën m·ªü tr√¨nh duy·ªát ƒë·ªÉ login v√† l∆∞u auth.json kh√¥ng? (y/n) [Enter=y]: ");
    const doLogin = (yn || "y").toLowerCase().startsWith("y");
    await maybeLoginAndSaveAuth({ enabled: doLogin, baseUrl: BASE_URL });
  }

  if (!OUTPUT_ROOT) {
    OUTPUT_ROOT = await ask("üì¶ Nh·∫≠p th∆∞ m·ª•c output (Enter = output): ");
    if (!OUTPUT_ROOT) OUTPUT_ROOT = "output";
  }
  ensureDir(OUTPUT_ROOT);

  if (!CONCURRENCY || Number.isNaN(CONCURRENCY)) {
    const c = await ask("‚öôÔ∏è S·ªë ·∫£nh t·∫£i song song (1‚Äì10, Enter = 3): ");
    CONCURRENCY = c ? parseInt(c, 10) : 3;
  }
  CONCURRENCY = Math.max(1, Math.min(10, CONCURRENCY));

  const headers = buildHeaders(BASE_URL);

  const defaultAuthPath = path.join(process.cwd(), "auth.json");
  const cookies = loadStorageStateCookies(defaultAuthPath);
  if (cookies.length) {
    console.log(`üç™ ƒê√£ n·∫°p cookies t·ª´ auth.json: ${cookies.length} cookies`);
  } else {
    console.log("üç™ Kh√¥ng th·∫•y auth.json ho·∫∑c kh√¥ng c√≥ cookies (ch·∫°y nh∆∞ b√¨nh th∆∞·ªùng).");
  }

  // ‚úÖ list chap files (supports decimals)
  const allFiles = fs.readdirSync(HTML_ROOT);

  const recognized = allFiles.filter(isChapFile);
  console.log(`üîé Nh·∫≠n chap files: ${recognized.length} file`);
  // in ra v√†i file ƒë·∫ßu ƒë·ªÉ debug n·∫øu c·∫ßn
  console.log("   V√≠ d·ª•:", recognized.slice(0, 15));

  const chapFiles = recognized.sort((a, b) => {
    const ka = parseChapKey(a) || { int: 0, frac: 0 };
    const kb = parseChapKey(b) || { int: 0, frac: 0 };
    if (ka.int !== kb.int) return ka.int - kb.int;
    if (ka.frac !== kb.frac) return ka.frac - kb.frac;
    return String(a).localeCompare(String(b));
  });

  if (!chapFiles.length) {
    console.log("‚ùå Kh√¥ng t√¨m th·∫•y chap_XXXX(.Y).html/htm/txt trong th∆∞ m·ª•c:", HTML_ROOT);
    console.log("   File trong folder (v√≠ d·ª• 20 file ƒë·∫ßu):", allFiles.slice(0, 20));
    return;
  }

  const firstFile = path.join(HTML_ROOT, chapFiles[0]);
  const first = readChapContent(firstFile);

  let firstUrls = [];
  if (first.kind === "txt") {
    firstUrls = first.urls || [];
  } else {
    firstUrls = extractImagesByDom(first.raw, BASE_URL);
    if (!firstUrls.length) firstUrls = extractImagesByRegex(first.raw);
  }

  if (!firstUrls.length) {
    console.log("‚ùå Kh√¥ng b√≥c ƒë∆∞·ª£c ·∫£nh t·ª´ chap ƒë·∫ßu.");
    console.log("   N·∫øu HTML c√≥ src d·∫°ng /image.php?... th√¨ b·∫°n PH·∫¢I nh·∫≠p base ƒë√∫ng.");
    return;
  }

  const firstAbs = normalizeMaybeRelativeUrl(firstUrls[0], BASE_URL) || firstUrls[0];
  const SERIES_NAME = getSeriesNameFromAnyUrl(unwrapProxyImageUrl(firstAbs) || firstAbs, BASE_URL);

  const SAVE_ROOT = path.join(OUTPUT_ROOT, SERIES_NAME);
  ensureDir(SAVE_ROOT);

  const FAILED_CHAPS = path.join(SAVE_ROOT, "failed_chaps.txt");
  const FAILED_IMAGES = path.join(SAVE_ROOT, "failed_images.txt");
  function markFailedChap(chap) {
    fs.appendFileSync(FAILED_CHAPS, chap + "\n");
  }
  function markFailedImage(chap, url, reason) {
    fs.appendFileSync(FAILED_IMAGES, `${chap}\t${url}\t${reason || ""}\n`);
  }

  console.log("\n==============================");
  console.log(`üìö B·ªô truy·ªán: ${SERIES_NAME}`);
  console.log(`üìÑ T·ªïng chap: ${chapFiles.length}`);
  console.log(`‚öôÔ∏è Concurrency: ${CONCURRENCY}`);
  console.log(`üìÅ Output: ${SAVE_ROOT}`);
  if (BASE_URL) console.log(`üåê Base: ${BASE_URL}`);
  console.log(`üß≠ Browser mode: ${HEADFUL ? "HEADFUL" : "HEADLESS"}`);
  if (ONLY_UNWRAP) console.log(`‚ö†Ô∏è ONLY_UNWRAP: ON (ch·ªâ t·∫£i ·∫£nh g·ªëc)`);
  console.log("==============================\n");

  const limit = pLimit(CONCURRENCY);

  while (true) {
    RESTART_REQUESTED = false;
    restartPromise = makeRestartPromise();

    const runId = ++CURRENT_RUN_ID;
    console.log(`\nüöÄ B·∫Øt ƒë·∫ßu RUN #${runId} t·ª´ chap ƒë·∫ßu... (nh·∫•n 'r' ƒë·ªÉ restart)\n`);

    for (let i = 0; i < chapFiles.length; i++) {
      if (RESTART_REQUESTED) break;

      const file = chapFiles[i];
      const num = chapNumber(file);
      if (!num) continue;

      const chapName = `chap_${num}`; // ‚úÖ normalized (e.g. chap_0102.5)
      const chapDir = path.join(SAVE_ROOT, chapName);

      CURRENT_CHAP_DIR = chapDir;
      ensureDir(chapDir);

      console.log(`üì• ${chapName} ‚Üí x·ª≠ l√Ω (${file})`);

      const fullPath = path.join(HTML_ROOT, file);
      const chap = readChapContent(fullPath);

      let imageUrls = [];
      if (chap.kind === "txt") {
        imageUrls = chap.urls || [];
      } else {
        imageUrls = extractImagesByDom(chap.raw, BASE_URL);
        if (!imageUrls.length) imageUrls = extractImagesByRegex(chap.raw);
      }

      if (RESTART_REQUESTED) break;

      if (!imageUrls.length) {
        console.log(`   ‚ùå Kh√¥ng t√¨m th·∫•y ·∫£nh`);
        markFailedChap(chapName);
        if (chap.kind === "html") {
          fs.writeFileSync(path.join(SAVE_ROOT, `debug_${chapName}.html`), chap.raw, "utf8");
        }
        CURRENT_CHAP_DIR = null;
        continue;
      }

      const existingIdx = getExistingImageIndexes(chapDir);
      const hadAnyImage = existingIdx.size > 0;
      const expectedTotal = imageUrls.length;
      const missingPositions = [];
      for (let pos = 0; pos < expectedTotal; pos++) {
        const fileIndex = pos + 1;
        if (!existingIdx.has(fileIndex)) missingPositions.push(pos);
      }

      const missingCount = missingPositions.length;
      if (missingCount === 0) {
        console.log(
          `   ${chapName} ‚Üí ${hadAnyImage ? "ƒë√£ c√≥ ·∫£nh trong folder" : "ch∆∞a c√≥ ·∫£nh trong folder"}, thi·∫øu 0 ·∫£nh, ƒë√£ b·ªï sung 0 ·∫£nh.-> c√≤n thi·∫øu 0 ·∫£nh ch∆∞a t·∫£i ƒë∆∞·ª£c.`
        );
        CURRENT_CHAP_DIR = null;
        await sleepInterruptible(randDelay(DELAY_CHAP_MIN, DELAY_CHAP_MAX));
        continue;
      }

      let ok = 0;
      let skipped = 0;
      let fail = 0;
      let downloaded = 0;

      const myRunId = runId;

      CURRENT_CHAP_ABORT = new AbortController();
      const signal = CURRENT_CHAP_ABORT.signal;

      const tasks = missingPositions.map((pos) =>
        limit(async () => {
          if (RESTART_REQUESTED || CURRENT_RUN_ID !== myRunId) return;
          if (signal.aborted) return;

          const u = imageUrls[pos];
          const imgNo = pos + 1;

          try {
            const r = await saveImageStable({
              index: imgNo,
              rawUrl: u,
              chapDir,
              headers,
              baseUrl: BASE_URL,
              cookies,
              signal,
            });

            if (RESTART_REQUESTED || CURRENT_RUN_ID !== myRunId) return;
            if (signal.aborted) return;

            if (r.ok) {
              ok++;
              if (r.skipped) skipped++;
              else downloaded++;
            } else {
              if (r.reason === "ABORTED") return;

              fail++;
              markFailedImage(chapName, normalizeMaybeRelativeUrl(u, BASE_URL) || u, r.reason);
              console.log(`   ‚ùå Img ${imgNo}: ${r.reason}`);
            }
          } catch (e) {
            if (RESTART_REQUESTED || CURRENT_RUN_ID !== myRunId) return;
            if (signal.aborted) return;

            const msg = e?.message || "download error";
            if (msg === "ABORTED") return;

            fail++;
            markFailedImage(chapName, normalizeMaybeRelativeUrl(u, BASE_URL) || u, msg);
            console.log(`   ‚ùå Img ${imgNo}: ${msg}`);
          }
        })
      );

      await Promise.race([Promise.all(tasks), restartPromise]);

      CURRENT_CHAP_ABORT = null;

      if (RESTART_REQUESTED) break;

      const remaining = Math.max(0, missingCount - (downloaded + skipped));
      console.log(
        `   ${chapName} ‚Üí ${hadAnyImage ? "ƒë√£ c√≥ ·∫£nh trong folder" : "ch∆∞a c√≥ ·∫£nh trong folder"}, thi·∫øu ${missingCount} ·∫£nh, ƒë√£ b·ªï sung ${downloaded} ·∫£nh.-> c√≤n thi·∫øu ${remaining} ·∫£nh ch∆∞a t·∫£i ƒë∆∞·ª£c.`
      );

      if (ok === 0 || fail / missingCount > 0.35) {
        console.log(`   ‚ö†Ô∏è T·ªâ l·ªá l·ªói cao ‚Üí ghi v√†o failed_chaps.txt`);
        markFailedChap(chapName);
      }

      CURRENT_CHAP_DIR = null;

      await sleepInterruptible(randDelay(DELAY_CHAP_MIN, DELAY_CHAP_MAX));
    }

    if (RESTART_REQUESTED) {
      RESTART_REQUESTED = false;
      restartPromise = makeRestartPromise();
      console.log("\nüîÅ RESTART: quay l·∫°i chap ƒë·∫ßu theo l·ªánh 'r'...\n");
      continue;
    }

    break;
  }

  console.log("\nüéâ HO√ÄN T·∫§T T·∫¢I TRUY·ªÜN");
  console.log(`üìå N·∫øu c√≥ l·ªói: xem failed_chaps.txt v√† failed_images.txt trong: ${SAVE_ROOT}`);
}

main().catch((e) => {
  console.error("üî• L·ªñI NGHI√äM TR·ªåNG:", e?.message || e);
  process.exit(1);
});
